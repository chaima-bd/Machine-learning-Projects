{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "8bde7417",
   "metadata": {},
   "source": [
    "# Atelier 5 : Apprentissage supervisé\n",
    "(Régression)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "81240b13",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.datasets import load_diabetes # Importation des données\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import cross_val_score, cross_val_predict\n",
    "from sklearn.model_selection import KFold\n",
    "import numpy as np\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "002f08f6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.collections.PathCollection at 0x1e29b1a1000>"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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RLYhxjnn+nMEs2bNYvr06Vx55ZVd302ZMoWjjz6aiy++uNfwX/3qV7njjjtYtmxZ13fz589n6dKlLFq0qOu7KIrYb7/9OOWUU7j//vtpbm7mD3/4w5tqU2trK3V1dbS0tFBbW/v2J05ERETeMW/l+N2vPTj5fJ5HH32UuXPn9vh+7ty5LFy4sGSdRYsW9Rr+kEMOYfHixRQKha7vLrzwQoYMGcKnP/3pN2xHLpejtbW1x0dERETKV78GnKamJqIooqGhocf3DQ0NNDY2lqzT2NhYcvgwDGlqagLggQce4JprruHqq69+U+24+OKLqaur6/qMHj36bUyNiIiIbCvekZuMjTE9/u2c6/XdGw2/9fu2tjY+9rGPcfXVV1NfX/+mxn/uuefS0tLS9Vm9evVbnAIRERHZlgT9+eP19fX4vt+rt2bDhg29emm2GjZsWMnhgyBg8ODBPP3007z88st86EMf6iq31gIQBAHLly9n++2371E/lUqRSqX+E5MkIiIi24B+7cFJJpPMmDGDBQsW9Ph+wYIFzJkzp2Sd2bNn9xr+7rvvZubMmSQSCSZPnsyTTz7J448/3vU58sgjOeCAA3j88cd1+UlERET6twcH4JxzzmHevHnMnDmT2bNn8/Of/5xVq1Yxf/58IL58tGbNGq677jogfmLqsssu45xzzuHUU09l0aJFXHPNNfzud78DIJ1OM23atB7jGDBgAECv70VEROT9qd8DzvHHH8+mTZu48MILWbduHdOmTePOO+9k7NixAKxbt67HO3HGjx/PnXfeydlnn83ll1/OiBEj+MlPfsIxxxzT300VERGRMtHv78F5L9J7cERERLY975n34IiIiIi8GxRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZeUcCzhVXXMH48eNJp9PMmDGD+++//3WHv++++5gxYwbpdJrtttuOq666qkf51VdfzT777MPAgQMZOHAgBx10EA8//HB/ToKIiIhsQ/o94Nx0002cddZZnHfeeSxZsoR99tmHww47jFWrVpUcfsWKFRx++OHss88+LFmyhK9//eucccYZ3HrrrV3D3HvvvZx44on84x//YNGiRYwZM4a5c+eyZs2a/p4cERER2QYY55zrzxHMmjWL6dOnc+WVV3Z9N2XKFI4++mguvvjiXsN/9atf5Y477mDZsmVd382fP5+lS5eyaNGikuOIooiBAwdy2WWX8fGPf/wN29Ta2kpdXR0tLS3U1ta+jakSERGRd9pbOX73aw9OPp/n0UcfZe7cuT2+nzt3LgsXLixZZ9GiRb2GP+SQQ1i8eDGFQqFknc7OTgqFAoMGDfrPNFxERES2aUF//nhTUxNRFNHQ0NDj+4aGBhobG0vWaWxsLDl8GIY0NTUxfPjwXnW+9rWvMXLkSA466KCSv5nL5cjlcl3/bm1tfauTIiIiItuQd+QmY2NMj38753p990bDl/oe4Pvf/z6/+93vuO2220in0yV/7+KLL6aurq7rM3r06Lc6CSIiIrIN6deAU19fj+/7vXprNmzY0KuXZqthw4aVHD4IAgYPHtzj+//+7//moosu4u6772bnnXfusx3nnnsuLS0tXZ/Vq1e/zSkSERGRbUG/BpxkMsmMGTNYsGBBj+8XLFjAnDlzStaZPXt2r+HvvvtuZs6cSSKR6PruBz/4Ad/5zne46667mDlz5uu2I5VKUVtb2+MjIiIi5avfL1Gdc845/OIXv+CXv/wly5Yt4+yzz2bVqlXMnz8fiHtXXv3k0/z581m5ciXnnHMOy5Yt45e//CXXXHMNX/7yl7uG+f73v883vvENfvnLXzJu3DgaGxtpbGykvb29vydHREREtgH9epMxwPHHH8+mTZu48MILWbduHdOmTePOO+9k7NixAKxbt67HO3HGjx/PnXfeydlnn83ll1/OiBEj+MlPfsIxxxzTNcwVV1xBPp/n2GOP7TGu888/nwsuuKC/J0lERETe4/r9PTjvRXoPjoiIyLbnPfMeHBEREZF3gwKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdt6RgHPFFVcwfvx40uk0M2bM4P7773/d4e+77z5mzJhBOp1mu+2246qrruo1zK233srUqVNJpVJMnTqV22+/vb+aLyIiItuYfg84N910E2eddRbnnXceS5YsYZ999uGwww5j1apVJYdfsWIFhx9+OPvssw9Llizh61//OmeccQa33npr1zCLFi3i+OOPZ968eSxdupR58+Zx3HHH8dBDD/X35IiIiMg2wDjnXH+OYNasWUyfPp0rr7yy67spU6Zw9NFHc/HFF/ca/qtf/Sp33HEHy5Yt6/pu/vz5LF26lEWLFgFw/PHH09rayl//+teuYQ499FAGDhzI7373uzdsU2trK3V1dbS0tFBbW/vvTJ6IiIi8Q97K8btfe3Dy+TyPPvooc+fO7fH93LlzWbhwYck6ixYt6jX8IYccwuLFiykUCq87TF+/mcvlaG1t7fERERGR8tWvAaepqYkoimhoaOjxfUNDA42NjSXrNDY2lhw+DEOampped5i+fvPiiy+mrq6u6zN69Oi3O0kiIiKyDXhHbjI2xvT4t3Ou13dvNPxrv38rv3nuuefS0tLS9Vm9evVbar+IiIhsW4L+/PH6+np83+/Vs7Jhw4ZePTBbDRs2rOTwQRAwePDg1x2mr99MpVKkUqm3OxkiIiKyjenXHpxkMsmMGTNYsGBBj+8XLFjAnDlzStaZPXt2r+HvvvtuZs6cSSKReN1h+vpNEREReX/p1x4cgHPOOYd58+Yxc+ZMZs+ezc9//nNWrVrF/Pnzgfjy0Zo1a7juuuuA+Impyy67jHPOOYdTTz2VRYsWcc011/R4OurMM89k33335dJLL+Woo47ij3/8I/fccw//+te/+ntyREREZBvQ7wHn+OOPZ9OmTVx44YWsW7eOadOmceeddzJ27FgA1q1b1+OdOOPHj+fOO+/k7LPP5vLLL2fEiBH85Cc/4ZhjjukaZs6cOdx444184xvf4Jvf/Cbbb789N910E7NmzervyREREZFtQL+/B+e9SO/BERER2fa8Z96DIyIiIvJuUMARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImVHAUdERETKjgKOiIiIlB0FHBERESk7CjgiIiJSdhRwREREpOwo4IiIiEjZUcARERGRsqOAIyIiImWnXwPOli1bmDdvHnV1ddTV1TFv3jyam5tft45zjgsuuIARI0ZQUVHB/vvvz9NPP91VvnnzZr74xS8yadIkKisrGTNmDGeccQYtLS39OSkiIiKyDenXgHPSSSfx+OOPc9ddd3HXXXfx+OOPM2/evNet8/3vf58f/vCHXHbZZTzyyCMMGzaMgw8+mLa2NgDWrl3L2rVr+e///m+efPJJfv3rX3PXXXfx6U9/uj8nRURERLYhxjnn+uOHly1bxtSpU3nwwQeZNWsWAA8++CCzZ8/m2WefZdKkSb3qOOcYMWIEZ511Fl/96lcByOVyNDQ0cOmll3LaaaeVHNctt9zCxz72MTo6OgiC4A3b1traSl1dHS0tLdTW1v4bUykiIiLvlLdy/O63HpxFixZRV1fXFW4A9txzT+rq6li4cGHJOitWrKCxsZG5c+d2fZdKpdhvv/36rAN0TeibCTciIiJS/votETQ2NjJ06NBe3w8dOpTGxsY+6wA0NDT0+L6hoYGVK1eWrLNp0ya+853v9Nm7A3EvUC6X6/p3a2vrG7ZfREREtl1vuQfnggsuwBjzup/FixcDYIzpVd85V/L7V3tteV91Wltb+eAHP8jUqVM5//zz+/y9iy++uOtG57q6OkaPHv1mJlVERES2UW+5B+f000/nhBNOeN1hxo0bxxNPPMH69et7lW3cuLFXD81Ww4YNA+KenOHDh3d9v2HDhl512traOPTQQ6murub2228nkUj02Z5zzz2Xc845p+vfra2tCjkiIiJl7C0HnPr6eurr699wuNmzZ9PS0sLDDz/MHnvsAcBDDz1ES0sLc+bMKVln/PjxDBs2jAULFrDbbrsBkM/nue+++7j00ku7hmttbeWQQw4hlUpxxx13kE6nX7ctqVSKVCr1ZidRREREtnH9dpPxlClTOPTQQzn11FN58MEHefDBBzn11FM54ogjejxBNXnyZG6//XYgvjR11llncdFFF3H77bfz1FNP8clPfpLKykpOOukkIO65mTt3Lh0dHVxzzTW0trbS2NhIY2MjURT11+SIiIjINqRfHzu64YYbOOOMM7qeijryyCO57LLLegyzfPnyHi/p+8pXvkImk+Hzn/88W7ZsYdasWdx9993U1NQA8Oijj/LQQw8BsMMOO/T4rRUrVjBu3Lh+nCIRERHZFvTbe3Dey/QeHBERkW3Pe+I9OCIiIiLvFgUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7CjgiIiISNlRwBEREZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUHQUcERERKTsKOCIiIlJ2FHBERESk7PRrwNmyZQvz5s2jrq6Ouro65s2bR3Nz8+vWcc5xwQUXMGLECCoqKth///15+umn+xz2sMMOwxjDH/7wh//8BIiIiMg2qV8DzkknncTjjz/OXXfdxV133cXjjz/OvHnzXrfO97//fX74wx9y2WWX8cgjjzBs2DAOPvhg2traeg374x//GGNMfzVfREREtlFBf/3wsmXLuOuuu3jwwQeZNWsWAFdffTWzZ89m+fLlTJo0qVcd5xw//vGPOe+88/jIRz4CwLXXXktDQwO//e1vOe2007qGXbp0KT/84Q955JFHGD58eH9NhoiIiGyD+q0HZ9GiRdTV1XWFG4A999yTuro6Fi5cWLLOihUraGxsZO7cuV3fpVIp9ttvvx51Ojs7OfHEE7nssssYNmzYG7Yll8vR2tra4yMiIiLlq98CTmNjI0OHDu31/dChQ2lsbOyzDkBDQ0OP7xsaGnrUOfvss5kzZw5HHXXUm2rLxRdf3HUfUF1dHaNHj36zkyEiIiLboLcccC644AKMMa/7Wbx4MUDJ+2Occ29438xry19d54477uDvf/87P/7xj990m88991xaWlq6PqtXr37TdUVERGTb85bvwTn99NM54YQTXneYcePG8cQTT7B+/fpeZRs3buzVQ7PV1stNjY2NPe6r2bBhQ1edv//977z44osMGDCgR91jjjmGffbZh3vvvbfX76ZSKVKp1Ou2WURERMrHWw449fX11NfXv+Fws2fPpqWlhYcffpg9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EZGyo4AjIiIiZUcBR0RERMqOAo6IiIiUnRJ/9rf8bX15c2tr67vcEhEREXmzth6338wfYXhfBpy2tjYARo8e/S63RERERN6qtrY26urqXneY9+XforLWsnbtWmpqanr88ch3W2trK6NHj2b16tX6G1nvMVo2721aPu9dWjbvbdva8nHO0dbWxogRI/C817/L5n3Zg+N5HqNGjXrjAd8ltbW128SK9n6kZfPepuXz3qVl8962LS2fN+q52Uo3GYuIiEjZUcARERGRsqOA8x6SSqU4//zzSaVS73ZT5DW0bN7btHzeu7Rs3tvKefm8L28yFhERkfKmHhwREREpOwo4IiIiUnYUcERERKTsKOCIiIhI2VHAeQdt2bKFefPmUVdXR11dHfPmzaO5ufl169x2220ccsgh1NfXY4zh8ccf7zVMLpfji1/8IvX19VRVVXHkkUfyyiuv9M9ElKm3s2ycc1xwwQWMGDGCiooK9t9/f55++ukew+y///4YY3p8TjjhhH6ckvJwxRVXMH78eNLpNDNmzOD+++9/3eHvu+8+ZsyYQTqdZrvttuOqq67qNcytt97K1KlTSaVSTJ06ldtvv72/ml/2/tPL59e//nWv7cQYQzab7c/JKEtvZdmsW7eOk046iUmTJuF5HmeddVbJ4bbZbcfJO+bQQw9106ZNcwsXLnQLFy5006ZNc0ccccTr1rnuuuvct7/9bXf11Vc7wC1ZsqTXMPPnz3cjR450CxYscI899pg74IAD3C677OLCMOynKSk/b2fZXHLJJa6mpsbdeuut7sknn3THH3+8Gz58uGttbe0aZr/99nOnnnqqW7duXdenubm5vydnm3bjjTe6RCLhrr76avfMM8+4M88801VVVbmVK1eWHP6ll15ylZWV7swzz3TPPPOMu/rqq10ikXC///3vu4ZZuHCh833fXXTRRW7ZsmXuoosuckEQuAcffPCdmqyy0R/L51e/+pWrra3tsZ2sW7funZqksvFWl82KFSvcGWec4a699lq36667ujPPPLPXMNvytqOA8w555plnHNBjpVi0aJED3LPPPvuG9VesWFEy4DQ3N7tEIuFuvPHGru/WrFnjPM9zd91113+s/eXs7Swba60bNmyYu+SSS7q+y2azrq6uzl111VVd3+23334ldxrStz322MPNnz+/x3eTJ092X/va10oO/5WvfMVNnjy5x3ennXaa23PPPbv+fdxxx7lDDz20xzCHHHKIO+GEE/5DrX7/6I/l86tf/crV1dX9x9v6fvNWl82r9bWv2pa3HV2ieocsWrSIuro6Zs2a1fXdnnvuSV1dHQsXLnzbv/voo49SKBSYO3du13cjRoxg2rRp/9bvvp+8nWWzYsUKGhsbe8z3VCrFfvvt16vODTfcQH19PTvuuCNf/vKXu/6avfSWz+d59NFHe8xXgLlz5/a5LBYtWtRr+EMOOYTFixdTKBRedxhtI29Nfy0fgPb2dsaOHcuoUaM44ogjWLJkyX9+AsrY21k2b8a2vO28L//Y5ruhsbGRoUOH9vp+6NChNDY2/lu/m0wmGThwYI/vGxoa/q3ffT95O8tm6/cNDQ09vm9oaGDlypVd/z755JMZP348w4YN46mnnuLcc89l6dKlLFiw4D84BeWjqamJKIpKztfXWxalhg/DkKamJoYPH97nMNpG3pr+Wj6TJ0/m17/+NTvttBOtra387//+L3vttRdLly5lwoQJ/TY95eTtLJs3Y1vedtSD82+64IILSt4c9+rP4sWLATDG9KrvnCv5/b+rv353W/JOLJvXlr+2zqmnnspBBx3EtGnTOOGEE/j973/PPffcw2OPPfYfmMLy9Ubz9c0M/9rv3+pvSt/+08tnzz335GMf+xi77LIL++yzDzfffDMTJ07kpz/96X+45eWvP9bzbXXbUQ/Ov+n0009/w6dixo0bxxNPPMH69et7lW3cuLFXOn4rhg0bRj6fZ8uWLT16cTZs2MCcOXPe9u+Wg/5cNsOGDQPis5vhw4d3fb9hw4bXXZ7Tp08nkUjw/PPPM3369DczGe8r9fX1+L7f6+zw9ebrsGHDSg4fBAGDBw9+3WH+nW3v/ai/ls9reZ7H7rvvzvPPP/+fafj7wNtZNm/GtrztqAfn31RfX8/kyZNf95NOp5k9ezYtLS08/PDDXXUfeughWlpa/q0gMmPGDBKJRI9LHuvWreOpp5563wec/lw2Wy87vXq+5/N57rvvvted708//TSFQqFHKJJuyWSSGTNm9LqEt2DBgj7n6+zZs3sNf/fddzNz5kwSicTrDvN+30beqv5aPq/lnOPxxx/XdvIWvJ1l82Zs09vOu3Nv8/vToYce6nbeeWe3aNEit2jRIrfTTjv1ehR50qRJ7rbbbuv696ZNm9ySJUvcX/7yFwe4G2+80S1ZsqTHI5Tz5893o0aNcvfcc4977LHH3IEHHqjHxN+it7NsLrnkEldXV+duu+029+STT7oTTzyxx2PiL7zwgvv2t7/tHnnkEbdixQr3l7/8xU2ePNnttttuWjavY+ujrtdcc4175pln3FlnneWqqqrcyy+/7Jxz7mtf+5qbN29e1/BbH0M+++yz3TPPPOOuueaaXo8hP/DAA873fXfJJZe4ZcuWuUsuuWSbedT1vaY/ls8FF1zg7rrrLvfiiy+6JUuWuFNOOcUFQeAeeuihd3z6tmVvddk459ySJUvckiVL3IwZM9xJJ53klixZ4p5++umu8m1521HAeQdt2rTJnXzyya6mpsbV1NS4k08+2W3ZsqXHMID71a9+1fXvX/3qVw7o9Tn//PO7hslkMu700093gwYNchUVFe6II45wq1atemcmqky8nWVjrXXnn3++GzZsmEulUm7fffd1Tz75ZFf5qlWr3L777usGDRrkksmk23777d0ZZ5zhNm3a9A5N1bbr8ssvd2PHjnXJZNJNnz7d3XfffV1ln/jEJ9x+++3XY/h7773X7bbbbi6ZTLpx48a5K6+8stdv3nLLLW7SpEkukUi4yZMnu1tvvbW/J6Ns/aeXz1lnneXGjBnjksmkGzJkiJs7d65buHDhOzEpZeetLptSx5exY8f2GGZb3XaMc8W7vURERETKhO7BERERkbKjgCMiIiJlRwFHREREyo4CjoiIiJQdBRwREREpOwo4IiIiUnYUcERERKTsKOCIiIhI2VHAERERkbKjgCMiIiJlRwFHREREyo4CjoiIiJSd/wc2PvGY+R6NCAAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "data = load_diabetes()\n",
    "#print(data)\n",
    "X = data.data\n",
    "y = data.target\n",
    "#print(y)\n",
    "import matplotlib.pyplot as plt\n",
    "plt.scatter(X[:,0],X[:,1],c=y,alpha=0.8)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1cc681cd",
   "metadata": {},
   "source": [
    "## 1- Entraîner les modèles de régression sur la base des diabètes en utilisant les deux stratégies\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f728063",
   "metadata": {},
   "source": [
    "###  Apprentissage traditionnel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "edba20be",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "train  (331, 10)\n",
      "test :  (111, 10)\n"
     ]
    }
   ],
   "source": [
    "# Splite the data \n",
    "# la stratégie d'apprentissage traditionnelle 75 pour E et 25 pour le test.\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)\n",
    "print(\"train \",X_train.shape)\n",
    "print(\"test : \",X_test.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "62f97074",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[157.44439211  68.25907478 161.8801239  119.48428364 264.59871597\n",
      " 124.31677164 160.74760036 119.61516051 218.87028988 247.56232184\n",
      " 197.35391054 151.78659679  38.60693452 172.2366586  243.16501599\n",
      " 232.7526966   81.95646528 187.11195375 134.40893825  99.54593802\n",
      " 235.71695952 115.62480576  63.41093401 279.66516249 181.55457641\n",
      " 179.74810208 111.07618389 188.4474363  151.24507263 196.640429\n",
      " 172.15896572 193.6234624   53.34973366 155.01211688 263.68926154\n",
      " 138.76772896 111.11766713 214.43587696 208.81201287 199.59745601\n",
      " 165.12920744  75.09665798 249.66595701 116.77723179 158.86752743\n",
      " 171.18249508 184.50881286 143.45447913  67.08273254 158.00359342\n",
      " 147.24015396 135.71315873 122.78970349 200.6755395  175.13783985\n",
      "  99.06391488 109.71337728 167.75828858 234.78345176  74.45657942\n",
      "  66.03257263  80.24570578  97.81192021 123.54903509 118.78961102\n",
      " 159.2823986  224.74008983 159.73104144 203.47871264  81.59458754\n",
      " 180.43290347 101.51252349 168.66275189  96.71557026 266.0918446\n",
      "  62.40479333 258.44763173 129.84042465 221.5664733  171.03193005\n",
      "  95.87478257 126.22704871  91.8946526   82.42711132 138.98122597\n",
      "  54.46952549 102.26287636 123.1551048  236.11370593 123.68935859\n",
      " 140.77178141 168.93806876 113.21725311 174.48896587 151.85088417\n",
      " 126.29424904 118.26295184 112.08306812 196.68828812 206.18689957\n",
      "  92.75931657  97.43439153 257.7646931   81.64565528 115.24175082\n",
      " 172.72087729 172.43783275  68.77956907 172.90870985  76.8516923\n",
      " 217.90887497]\n"
     ]
    }
   ],
   "source": [
    "from sklearn.linear_model import LinearRegression\n",
    "\n",
    "# Initialiser le modèle de régression linéaire\n",
    "lr_model = LinearRegression()\n",
    "\n",
    "# Entraîner le modèle sur l'ensemble d'apprentissage\n",
    "lr_model.fit(X_train, y_train)\n",
    "\n",
    "# Faire des prédictions sur l'ensemble de test\n",
    "y_pred_lr = lr_model.predict(X_test)\n",
    "print(y_pred_lr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "80082084",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.preprocessing import PolynomialFeatures\n",
    "\n",
    "# Créer des fonctionnalités polynomiales de degré 2\n",
    "poly = PolynomialFeatures(degree=2)\n",
    "X_poly_train = poly.fit_transform(X_train)\n",
    "X_poly_test = poly.fit_transform(X_test)\n",
    "\n",
    "# Initialiser le modèle de régression linéaire avec des fonctionnalités polynomiales\n",
    "poly_model = LinearRegression()\n",
    "\n",
    "# Entraîner le modèle sur l'ensemble d'apprentissage avec les fonctionnalités polynomiales\n",
    "poly_model.fit(X_poly_train, y_train)\n",
    "\n",
    "# Faire des prédictions sur l'ensemble de test avec les fonctionnalités polynomiales\n",
    "y_pred_poly = poly_model.predict(X_poly_test)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "d97f798f",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.neighbors import KNeighborsRegressor\n",
    "\n",
    "# Initialiser le modèle KNN avec k=5\n",
    "knn_model = KNeighborsRegressor(n_neighbors=5)\n",
    "\n",
    "# Entraîner le modèle sur l'ensemble d'apprentissage\n",
    "knn_model.fit(X_train, y_train)\n",
    "\n",
    "# Faire des prédictions sur l'ensemble de test\n",
    "y_pred_knn = knn_model.predict(X_test)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d947cd57",
   "metadata": {},
   "source": [
    "### Apprentissage validation croisée "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "7986ce3d",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "#############################\n",
      "#############################\n",
      "#############################\n",
      "#############################\n",
      "#############################\n"
     ]
    }
   ],
   "source": [
    "############\n",
    "# Définir le nombre de plis pour la validation croisée\n",
    "k = 5\n",
    "\n",
    "# Créer un objet KFold pour la validation croisée\n",
    "kf = KFold(n_splits=k, shuffle=True, random_state=42)\n",
    "\n",
    "# Initialiser une liste pour stocker les prédictions de chaque pli\n",
    "predictions_lr = []\n",
    "predictions_poly = []\n",
    "predictions_knn = []\n",
    "\n",
    "# Boucle sur chaque pli de validation croisée\n",
    "for train_index, test_index in kf.split(X_train):\n",
    "    \n",
    "    # Extraire les ensembles de formation et de test pour ce pli\n",
    "    X_train_fold, X_test_fold = X_train[train_index], X_train[test_index]\n",
    "    y_train_fold, y_test_fold = y_train[train_index], y_train[test_index]\n",
    "    \n",
    "    # Entraîner le modèle sur les données de formation de ce pli\n",
    "    lr_model.fit(X_train_fold, y_train_fold)\n",
    "    poly_model.fit(X_train_fold, y_train_fold)\n",
    "    knn_model.fit(X_train_fold, y_train_fold)\n",
    "    \n",
    "    # Faire des prédictions sur les données de test de ce pli\n",
    "    y_pred_fold_lr = lr_model.predict(X_test_fold)\n",
    "    y_pred_fold_poly = poly_model.predict(X_test_fold)\n",
    "    y_pred_fold_knn = knn_model.predict(X_test_fold)\n",
    "    \n",
    "    #print(y_pred_fold_lr)\n",
    "    #print(y_pred_fold_poly)\n",
    "    #print(y_pred_fold_knn)\n",
    "    print(\"#############################\")\n",
    "    # Ajouter les prédictions à la liste\n",
    "    predictions_lr.extend(y_pred_fold_lr)\n",
    "    predictions_poly.extend(y_pred_fold_poly)\n",
    "    predictions_knn.extend(y_pred_fold_knn)\n",
    "    "
   ]
  },
  {
   "cell_type": "raw",
   "id": "4858b635",
   "metadata": {},
   "source": [
    "# PolynomialFeatures Avec la method de validation croisée\n",
    "poly_scores  = cross_val_score(poly_model,X_train,y_train,cv=5)\n",
    "#Affichage des résultats\n",
    "print (\"Le score obtenu pour chacun des 5 fold créé est : \",poly_scores )\n",
    "print (\"Cela fait une moyenne de : \",poly_scores.mean())\n",
    "print (\"Et un écart-type de  : \",poly_scores.std())"
   ]
  },
  {
   "cell_type": "raw",
   "id": "5919b074",
   "metadata": {},
   "source": [
    "knn_scores = cross_val_score(knn_model, X, y, cv=10)\n",
    "#Affichage des résultats\n",
    "print (\"Le score obtenu pour chacun des 5 fold créé est : \",knn_scores )\n",
    "print (\"Cela fait une moyenne de : \",knn_scores.mean())\n",
    "print (\"Et un écart-type de  : \",knn_scores.std())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "286ceb49",
   "metadata": {},
   "source": [
    "## 2- Evaluer les performances des modèles obtenus, en quantifiant leur erreur avec les métriques  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "id": "059f7ea9",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.metrics import mean_squared_error #Erreur quadratique moyenne (MSE)\n",
    "from sklearn.metrics import mean_absolute_error #Erreur absolue moyenne (MAE)\n",
    "from sklearn.metrics import mean_squared_error #Racine de l’erreur quadratique moyenne (RMSE)\n",
    "from sklearn.metrics import mean_squared_log_error #Racine du log de l’erreur quadratique moyenne (RMSLE)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "be149dc7",
   "metadata": {},
   "source": [
    "### 1:LinearRegression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "28da272e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0\n",
      "MSE d'apprentissage traditionnelle: 2917.1127047637606\n",
      "MAE d'apprentissage traditionnelle: 43.349234567015394\n",
      "RMSE d'apprentissage traditionnelle: 2917.1127047637606\n",
      "RMSLE d'apprentissage traditionnelle: 0.17087078600969444\n"
     ]
    }
   ],
   "source": [
    "# la stratégie d'apprentissage traditionnelle\n",
    "# Calculer l'erreur quadratique moyenne entre les prédictions et les vraies valeurs\n",
    "mse_lr = mean_squared_error(y_test, y_pred_lr)\n",
    "mae_lr = mean_absolute_error(y_test, y_pred_lr)\n",
    "rmse_lr = mean_squared_error(y_test, y_pred_lr)\n",
    "rmsle_lr = mean_squared_log_error(y_test, y_pred_lr)\n",
    "print(mean_squared_log_error(y_train, y_train))\n",
    "\n",
    "\n",
    "# Afficher l'erreur quadratique moyenne\n",
    "print(\"MSE d'apprentissage traditionnelle:\", mse_lr)\n",
    "print(\"MAE d'apprentissage traditionnelle:\", mae_lr)\n",
    "print(\"RMSE d'apprentissage traditionnelle:\", rmse_lr)\n",
    "print(\"RMSLE d'apprentissage traditionnelle:\", rmsle_lr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "id": "634750f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Prédiction sur les données d'entraînement\n",
    "y_pred_lr_train = lr_model.predict(X_train)\n",
    "# Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble d'entraînement\n",
    "mse_lr_train = mean_squared_error(y_train, y_pred_lr_train)\n",
    "mae_lr_train = mean_absolute_error(y_train, y_pred_lr_train)\n",
    "rmse_lr_train = mean_squared_error(y_train, y_pred_lr_train)\n",
    "rmsle_lr_train = mean_squared_log_error(y_train, y_pred_lr_train)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "id": "ca3cfc60",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# Initialisation des scores\n",
    "mse_train_scores_lr = []\n",
    "mae_train_scores_lr = []\n",
    "rmse_train_scores_lr = []\n",
    "rmsle_train_scores_lr = []\n",
    "\n",
    "mse_val_scores_lr = []\n",
    "mae_val_scores_lr = []\n",
    "rmse_val_scores_lr = []\n",
    "rmsle_val_scores_lr = []\n",
    "# Définition de la validation croisée avec K=5 folds\n",
    "kf = KFold(n_splits=5)\n",
    "# Boucle sur les folds\n",
    "for train_index, val_index in kf.split(X_train):\n",
    "    \n",
    "    # Séparation des données d'entraînement et de validation\n",
    "    X_train_fold, X_val_fold = X_train[train_index], X_train[val_index]\n",
    "    y_train_fold, y_val_fold = y_train[train_index], y_train[val_index]\n",
    "    \n",
    "    # Initialisation et entraînement du modèle de régression linéaire\n",
    "    lr = LinearRegression()\n",
    "    lr.fit(X_train_fold, y_train_fold)\n",
    "    \n",
    "    # Prédiction sur les données d'entraînement\n",
    "    y_pred_train = lr.predict(X_train_fold)\n",
    "    \n",
    "    # Prédiction sur les données de validation\n",
    "    y_pred_val = lr.predict(X_val_fold)\n",
    "    \n",
    "    # Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble d'entraînement\n",
    "    mse_train_scores_lr.append(mean_squared_error(y_train_fold, y_pred_train))\n",
    "    mae_train_scores_lr.append(mean_absolute_error(y_train_fold, y_pred_train))\n",
    "    rmse_train_scores_lr.append(np.sqrt(mean_squared_error(y_train_fold, y_pred_train)))\n",
    "    rmsle_train_scores_lr.append(np.sqrt(mean_squared_error(np.log(y_train_fold+1), np.log(y_pred_train+1))))\n",
    "    \n",
    "    # Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble de validation\n",
    "    mse_val_scores_lr.append(mean_squared_error(y_val_fold, y_pred_val))\n",
    "    mae_val_scores_lr.append(mean_absolute_error(y_val_fold, y_pred_val))\n",
    "    rmse_val_scores_lr.append(np.sqrt(mean_squared_error(y_val_fold, y_pred_val)))\n",
    "    rmsle_val_scores_lr.append(np.sqrt(mean_squared_error(np.log(y_val_fold+1), np.log(y_pred_val+1))))\n",
    "\n",
    "# Moyenne des scores d'erreur pour l'ensemble d'entraînement\n",
    "mse_train_scores_lr = np.mean(mse_train_scores)\n",
    "mae_train_score_lr = np.mean(mae_train_scores)\n",
    "rmse_train_score_lr =  np.mean(rmse_train_scores)\n",
    "rmsle_train_score_lr =  np.mean(rmsle_train_scores)\n",
    "\n",
    "# Moyenne des scores d'erreur pour l'ensemble de validation \n",
    "mse_scores_lr = np.mean(mse_val_scores)\n",
    "mae_scores_lr = np.mean(mae_val_scores)\n",
    "rmse_scores_lr = np.mean(rmse_val_scores)\n",
    "rmsle_scores_lr = np.mean(rmsle_val_scores)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "id": "edcca02d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Moyenne des scores d'erreur pour l'ensemble d'entraînement :\n",
      "MSE :  2889.2025114767966\n",
      "MAE :  43.61633258962668\n",
      "RMSE :  53.73688237421406\n",
      "RMSLE :  0.42996613758019925\n",
      "Moyenne des scores d'erreur pour l'ensemble de validation :\n",
      "MSE :  3230.8819818332886\n",
      "MAE :  46.15765890029557\n",
      "RMSE :  56.57764987212769\n",
      "RMSLE :  0.44625067122335393\n"
     ]
    }
   ],
   "source": [
    "# Affichage des scores moyens pour l'ensemble d'entraînement et de validation\n",
    "print(\"Moyenne des scores d'erreur pour l'ensemble d'entraînement :\")\n",
    "print(\"MSE : \", mse_train_scores_lr)\n",
    "print(\"MAE : \", mae_train_score_lr)\n",
    "print(\"RMSE : \", rmse_train_score_lr)\n",
    "print(\"RMSLE : \", rmsle_train_score_lr)\n",
    "\n",
    "print(\"Moyenne des scores d'erreur pour l'ensemble de validation :\")\n",
    "print(\"MSE : \", mse_scores_lr)\n",
    "print(\"MAE : \", mae_scores_lr)\n",
    "print(\"RMSE : \", rmse_scores_lr)\n",
    "print(\"RMSLE : \", rmsle_scores_lr)"
   ]
  },
  {
   "cell_type": "raw",
   "id": "5bf144f3",
   "metadata": {},
   "source": [
    "# validation croisée \n",
    "# Calculer le score de MSE pour la validation croisée\n",
    "mse_scores_lr = -cross_val_score(lr_model, X, y, cv=5, scoring='neg_mean_squared_error')\n",
    "# Calculer le score de MAE pour la validation croisée\n",
    "mae_scores_lr = -cross_val_score(lr_model, X, y, cv=5, scoring='neg_mean_absolute_error')\n",
    "# Calculer le score de RMSE pour la validation croisée\n",
    "rmse_scores_lr = np.sqrt(mse_scores_lr)\n",
    "# Calculer le score de RMSLE pour la validation croisée\n",
    "rmsle_scores_lr = np.sqrt(np.mean(np.log(np.clip((y - lr_model.predict(X)) ** 2, 1e-10, float('inf')))))\n",
    "\n",
    "# Afficher les scores moyens de chaque métrique d'évaluation\n",
    "print(\"MSE: \", mse_scores_lr.mean())\n",
    "print(\"MAE: \", mae_scores_lr.mean())\n",
    "print(\"RMSE: \", rmse_scores_lr.mean())\n",
    "print(\"RMSLE: \", rmsle_scores_lr)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd89ba58",
   "metadata": {},
   "source": [
    "### 2:PolynomialFeatures "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "22715f9d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MSE d'apprentissage traditionnelle: 4853.553485446568\n",
      "MAE d'apprentissage traditionnelle: 52.43009895558274\n",
      "RMSE d'apprentissage traditionnelle: 4853.553485446568\n",
      "RMSLE d'apprentissage traditionnelle: 0.21543211866330192\n"
     ]
    }
   ],
   "source": [
    "# la stratégie d'apprentissage traditionnelle\n",
    "# Calculer l'erreur quadratique moyenne entre les prédictions et les vraies valeurs\n",
    "mse_poly = mean_squared_error(y_test, y_pred_poly)\n",
    "mae_poly = mean_absolute_error(y_test, y_pred_poly)\n",
    "rmse_poly = mean_squared_error(y_test, y_pred_poly)\n",
    "rmsle_poly = mean_squared_log_error(y_test, y_pred_poly)\n",
    "\n",
    "# Afficher l'erreur quadratique moyenne\n",
    "print(\"MSE d'apprentissage traditionnelle:\", mse_poly)\n",
    "print(\"MAE d'apprentissage traditionnelle:\", mae_poly)\n",
    "print(\"RMSE d'apprentissage traditionnelle:\", rmse_poly)\n",
    "print(\"RMSLE d'apprentissage traditionnelle:\", rmsle_poly)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "id": "2db050d5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Prédiction sur les données d'entraînement\n",
    "y_pred_poly_train = poly_model.predict(X_train)\n",
    "# Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble d'entraînement\n",
    "mse_poly_train = mean_squared_error(y_train, y_pred_poly_train)\n",
    "mae_poly_train = mean_absolute_error(y_train, y_pred_poly_train)\n",
    "rmse_poly_train = mean_squared_error(y_train, y_pred_poly_train)\n",
    "rmsle_poly_train = mean_squared_log_error(y_train, y_pred_poly_train)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "id": "b589b2f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initialisation des scores\n",
    "mse_train_scores_poly = []\n",
    "mae_train_scores_poly  = []\n",
    "rmse_train_scores_poly  = []\n",
    "rmsle_train_scores_poly  = []\n",
    "\n",
    "mse_val_scores_poly  = []\n",
    "mae_val_scores_poly  = []\n",
    "rmse_val_scores_poly  = []\n",
    "rmsle_val_scores_poly  = []\n",
    "# Définition de la validation croisée avec K=5 folds\n",
    "kf = KFold(n_splits=5)\n",
    "# Boucle sur les folds\n",
    "for train_index, val_index in kf.split(X_train):\n",
    "    \n",
    "    # Séparation des données d'entraînement et de validation\n",
    "    X_train_fold, X_val_fold = X_train[train_index], X_train[val_index]\n",
    "    y_train_fold, y_val_fold = y_train[train_index], y_train[val_index]\n",
    "    \n",
    "    # Initialisation et entraînement du modèle de régression linéaire\n",
    "  \n",
    "    poly_model.fit(X_train_fold, y_train_fold)\n",
    "    \n",
    "    # Prédiction sur les données d'entraînement\n",
    "    y_pred_train_poly = poly_model.predict(X_train_fold)\n",
    "    \n",
    "    # Prédiction sur les données de validation\n",
    "    y_pred_val_poly = poly_model.predict(X_val_fold)\n",
    "    \n",
    "    # Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble d'entraînement\n",
    "    mse_train_scores_poly.append(mean_squared_error(y_train_fold, y_pred_train_poly))\n",
    "    mae_train_scores_poly.append(mean_absolute_error(y_train_fold, y_pred_train_poly))\n",
    "    rmse_train_scores_poly.append(np.sqrt(mean_squared_error(y_train_fold, y_pred_train_poly)))\n",
    "    rmsle_train_scores_poly.append(np.sqrt(mean_squared_error(np.log(y_train_fold+1), np.log(y_pred_train_poly+1))))\n",
    "    \n",
    "    # Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble de validation\n",
    "    mse_val_scores_poly.append(mean_squared_error(y_val_fold, y_pred_val_poly))\n",
    "    mae_val_scores_poly.append(mean_absolute_error(y_val_fold, y_pred_val_poly))\n",
    "    rmse_val_scores_poly.append(np.sqrt(mean_squared_error(y_val_fold, y_pred_val_poly)))\n",
    "    rmsle_val_scores_poly.append(np.sqrt(mean_squared_error(np.log(y_val_fold+1), np.log(y_pred_val_poly+1))))\n",
    "\n",
    "# Moyenne des scores d'erreur pour l'ensemble d'entraînement\n",
    "mse_train_scores_poly = np.mean(mse_train_scores_poly)\n",
    "mae_train_score_poly = np.mean(mae_train_scores_poly)\n",
    "rmse_train_score_poly =  np.mean(rmse_train_scores_poly)\n",
    "rmsle_train_score_poly =  np.mean(rmsle_train_scores_poly)\n",
    "\n",
    "# Moyenne des scores d'erreur pour l'ensemble de validation \n",
    "mse_scores_poly = np.mean(mse_val_scores_poly)\n",
    "mae_scores_poly = np.mean(mae_val_scores_poly)\n",
    "rmse_scores_poly = np.mean(rmse_val_scores_poly)\n",
    "rmsle_scores_poly = np.mean(rmsle_val_scores_poly)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "id": "fc5a2ba5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Moyenne des scores d'erreur pour l'ensemble d'entraînement :\n",
      "MSE :  2829.4273340050677\n",
      "MAE :  43.26277926356257\n",
      "RMSE :  53.183959071662365\n",
      "RMSLE :  0.4150960319367383\n",
      "Moyenne des scores d'erreur pour l'ensemble de validation :\n",
      "MSE :  3221.625571420371\n",
      "MAE :  46.219619204716274\n",
      "RMSE :  56.57673552331058\n",
      "RMSLE :  0.43701967885322046\n"
     ]
    }
   ],
   "source": [
    "# Affichage des scores moyens pour l'ensemble d'entraînement et de validation\n",
    "print(\"Moyenne des scores d'erreur pour l'ensemble d'entraînement :\")\n",
    "print(\"MSE : \", mse_train_scores_poly)\n",
    "print(\"MAE : \", mae_train_score_poly)\n",
    "print(\"RMSE : \", rmse_train_score_poly)\n",
    "print(\"RMSLE : \", rmsle_train_score_poly)\n",
    "\n",
    "print(\"Moyenne des scores d'erreur pour l'ensemble de validation :\")\n",
    "print(\"MSE : \", mse_scores_poly)\n",
    "print(\"MAE : \", mae_scores_poly)\n",
    "print(\"RMSE : \", rmse_scores_poly)\n",
    "print(\"RMSLE : \", rmsle_scores_poly)"
   ]
  },
  {
   "cell_type": "raw",
   "id": "1924832f",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "# Calculer le score de MSE pour la validation croisée\n",
    "mse_scores_poly = -cross_val_score(poly_model, X, y, cv=5, scoring='neg_mean_squared_error')\n",
    "# Calculer le score de MAE pour la validation croisée\n",
    "mae_scores_poly = -cross_val_score(poly_model, X, y, cv=5, scoring='neg_mean_absolute_error')\n",
    "# Calculer le score de RMSE pour la validation croisée\n",
    "rmse_scores_poly = np.sqrt(mse_scores_poly)\n",
    "# Calculer le score de RMSLE pour la validation croisée\n",
    "rmsle_scores_poly = np.sqrt(np.mean(np.log(np.clip((y - poly_model.predict(X)) ** 2, 1e-10, float('inf')))))\n",
    "\n",
    "# Afficher les scores moyens de chaque métrique d'évaluation\n",
    "print(\"MSE: \", mse_scores_poly.mean())\n",
    "print(\"MAE: \", mae_scores_poly.mean())\n",
    "print(\"RMSE: \", rmse_scores_poly.mean())\n",
    "print(\"RMSLE: \", rmsle_scores_poly)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "151e5f0d",
   "metadata": {},
   "source": [
    "### 3:KNN "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "id": "ab367fc3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MSE d'apprentissage traditionnelle: 3546.8400000000006\n",
      "MAE d'apprentissage traditionnelle: 46.10630630630631\n",
      "RMSE d'apprentissage traditionnelle: 3546.8400000000006\n",
      "RMSLE d'apprentissage traditionnelle: 0.1887947854250726\n"
     ]
    }
   ],
   "source": [
    "# la stratégie d'apprentissage traditionnelle\n",
    "# Calculer l'erreur quadratique moyenne entre les prédictions et les vraies valeurs\n",
    "mse_knn = mean_squared_error(y_test, y_pred_knn)\n",
    "mae_knn = mean_absolute_error(y_test, y_pred_knn)\n",
    "rmse_knn = mean_squared_error(y_test, y_pred_knn)\n",
    "rmsle_knn = mean_squared_log_error(y_test, y_pred_knn)\n",
    "\n",
    "# Afficher l'erreur quadratique moyenne\n",
    "print(\"MSE d'apprentissage traditionnelle:\", mse_knn)\n",
    "print(\"MAE d'apprentissage traditionnelle:\", mae_knn)\n",
    "print(\"RMSE d'apprentissage traditionnelle:\", rmse_knn)\n",
    "print(\"RMSLE d'apprentissage traditionnelle:\", rmsle_knn)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "19107bfd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Prédiction sur les données d'entraînement\n",
    "y_pred_knn_train = poly_model.predict(X_train)\n",
    "# Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble d'entraînement\n",
    "mse_knn_train = mean_squared_error(y_train, y_pred_knn_train)\n",
    "mae_knn_train = mean_absolute_error(y_train, y_pred_knn_train)\n",
    "rmse_knn_train = mean_squared_error(y_train, y_pred_knn_train)\n",
    "rmsle_knn_train = mean_squared_log_error(y_train, y_pred_knn_train)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "0fbeec44",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initialisation des scores\n",
    "mse_train_scores_knn = []\n",
    "mae_train_scores_knn  = []\n",
    "rmse_train_scores_knn  = []\n",
    "rmsle_train_scores_knn  = []\n",
    "\n",
    "mse_val_scores_knn  = []\n",
    "mae_val_scores_knn  = []\n",
    "rmse_val_scores_knn  = []\n",
    "rmsle_val_scores_knn  = []\n",
    "# Définition de la validation croisée avec K=5 folds\n",
    "kf = KFold(n_splits=5)\n",
    "# Boucle sur les folds\n",
    "for train_index, val_index in kf.split(X_train):\n",
    "    \n",
    "    # Séparation des données d'entraînement et de validation\n",
    "    X_train_fold, X_val_fold = X_train[train_index], X_train[val_index]\n",
    "    y_train_fold, y_val_fold = y_train[train_index], y_train[val_index]\n",
    "    \n",
    "    # Initialisation et entraînement du modèle de régression linéaire\n",
    "  \n",
    "    knn_model.fit(X_train_fold, y_train_fold)\n",
    "    \n",
    "    # Prédiction sur les données d'entraînement\n",
    "    y_pred_train_knn = knn_model.predict(X_train_fold)\n",
    "    \n",
    "    # Prédiction sur les données de validation\n",
    "    y_pred_val_knn = knn_model.predict(X_val_fold)\n",
    "    \n",
    "    # Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble d'entraînement\n",
    "    mse_train_scores_knn.append(mean_squared_error(y_train_fold, y_pred_train_knn))\n",
    "    mae_train_scores_knn.append(mean_absolute_error(y_train_fold, y_pred_train_knn))\n",
    "    rmse_train_scores_knn.append(np.sqrt(mean_squared_error(y_train_fold, y_pred_train_knn)))\n",
    "    rmsle_train_scores_knn.append(np.sqrt(mean_squared_error(np.log(y_train_fold+1), np.log(y_pred_train_knn+1))))\n",
    "    \n",
    "    # Calcul des scores de MSE, MAE, RMSE et RMSLE pour l'ensemble de validation\n",
    "    mse_val_scores_knn.append(mean_squared_error(y_val_fold, y_pred_val_knn))\n",
    "    mae_val_scores_knn.append(mean_absolute_error(y_val_fold, y_pred_val_knn))\n",
    "    rmse_val_scores_knn.append(np.sqrt(mean_squared_error(y_val_fold, y_pred_val_knn)))\n",
    "    rmsle_val_scores_knn.append(np.sqrt(mean_squared_error(np.log(y_val_fold+1), np.log(y_pred_val_knn+1))))\n",
    "\n",
    "# Moyenne des scores d'erreur pour l'ensemble d'entraînement\n",
    "mse_train_scores_knn = np.mean(mse_train_scores_knn)\n",
    "mae_train_score_knn = np.mean(mae_train_scores_knn)\n",
    "rmse_train_score_knn =  np.mean(rmse_train_scores_knn)\n",
    "rmsle_train_score_knn =  np.mean(rmsle_train_scores_knn)\n",
    "\n",
    "# Moyenne des scores d'erreur pour l'ensemble de validation \n",
    "mse_scores_knn = np.mean(mse_val_scores_knn)\n",
    "mae_scores_knn = np.mean(mae_val_scores_knn)\n",
    "rmse_scores_knn = np.mean(rmse_val_scores_knn)\n",
    "rmsle_scores_knn = np.mean(rmsle_val_scores_knn)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "542ee30b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Moyenne des scores d'erreur pour l'ensemble d'entraînement :\n",
      "MSE :  2610.137916409377\n",
      "MAE :  40.61879874213837\n",
      "RMSE :  51.074111573729354\n",
      "RMSLE :  0.37499902952218445\n",
      "Moyenne des scores d'erreur pour l'ensemble de validation :\n",
      "MSE :  3994.9200850293987\n",
      "MAE :  50.240859339665306\n",
      "RMSE :  63.102733963816924\n",
      "RMSLE :  0.467985025681395\n"
     ]
    }
   ],
   "source": [
    "# Affichage des scores moyens pour l'ensemble d'entraînement et de validation\n",
    "print(\"Moyenne des scores d'erreur pour l'ensemble d'entraînement :\")\n",
    "print(\"MSE : \", mse_train_scores_knn)\n",
    "print(\"MAE : \", mae_train_score_knn)\n",
    "print(\"RMSE : \", rmse_train_score_knn)\n",
    "print(\"RMSLE : \", rmsle_train_score_knn)\n",
    "\n",
    "print(\"Moyenne des scores d'erreur pour l'ensemble de validation :\")\n",
    "print(\"MSE : \", mse_scores_knn)\n",
    "print(\"MAE : \", mae_scores_knn)\n",
    "print(\"RMSE : \", rmse_scores_knn)\n",
    "print(\"RMSLE : \", rmsle_scores_knn)"
   ]
  },
  {
   "cell_type": "raw",
   "id": "19f25ab2",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "# Calculer le score de MSE pour la validation croisée\n",
    "mse_scores_knn = -cross_val_score(knn_model, X, y, cv=5, scoring='neg_mean_squared_error')\n",
    "# Calculer le score de MAE pour la validation croisée\n",
    "mae_scores_knn = -cross_val_score(knn_model, X, y, cv=5, scoring='neg_mean_absolute_error')\n",
    "# Calculer le score de RMSE pour la validation croisée\n",
    "rmse_scores_knn = np.sqrt(mse_scores_knn)\n",
    "# Calculer le score de RMSLE pour la validation croisée\n",
    "rmsle_scores_knn = np.sqrt(np.mean(np.log(np.clip((y - knn_model.predict(X)) ** 2, 1e-10, float('inf')))))\n",
    "\n",
    "# Afficher les scores moyens de chaque métrique d'évaluation\n",
    "print(\"MSE: \", mse_scores_knn.mean())\n",
    "print(\"MAE: \", mae_scores_knn.mean())\n",
    "print(\"RMSE: \", rmse_scores_knn.mean())\n",
    "print(\"RMSLE: \", rmsle_scores_knn)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "24306440",
   "metadata": {},
   "source": [
    "## Comparer les performances des modèles, et donner une interprétation des résultats obtenus "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "id": "8e755a97",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>lr-tradi_train</th>\n",
       "      <th>lr-tradi_val</th>\n",
       "      <th>lr-VC_train</th>\n",
       "      <th>lr-VC_val</th>\n",
       "      <th>poly-tradi_train</th>\n",
       "      <th>poly-tradi_test</th>\n",
       "      <th>poly-VC_train</th>\n",
       "      <th>poly-VC_test</th>\n",
       "      <th>knn-tradi_train</th>\n",
       "      <th>knn-tradi_test</th>\n",
       "      <th>knn-VC_train</th>\n",
       "      <th>knn-VC_test</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>MSE</th>\n",
       "      <td>2913.873492</td>\n",
       "      <td>2917.112705</td>\n",
       "      <td>2889.202511</td>\n",
       "      <td>3230.881982</td>\n",
       "      <td>2913.873492</td>\n",
       "      <td>4853.553485</td>\n",
       "      <td>2829.427334</td>\n",
       "      <td>3221.625571</td>\n",
       "      <td>2884.757413</td>\n",
       "      <td>3546.840000</td>\n",
       "      <td>2610.137916</td>\n",
       "      <td>3994.920085</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>MAE</th>\n",
       "      <td>43.792506</td>\n",
       "      <td>43.349235</td>\n",
       "      <td>43.616333</td>\n",
       "      <td>46.157659</td>\n",
       "      <td>43.792506</td>\n",
       "      <td>52.430099</td>\n",
       "      <td>43.262779</td>\n",
       "      <td>46.219619</td>\n",
       "      <td>43.934380</td>\n",
       "      <td>46.106306</td>\n",
       "      <td>40.618799</td>\n",
       "      <td>50.240859</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>RMSE</th>\n",
       "      <td>2913.873492</td>\n",
       "      <td>2917.112705</td>\n",
       "      <td>53.736882</td>\n",
       "      <td>56.577650</td>\n",
       "      <td>2913.873492</td>\n",
       "      <td>4853.553485</td>\n",
       "      <td>53.183959</td>\n",
       "      <td>56.576736</td>\n",
       "      <td>2884.757413</td>\n",
       "      <td>3546.840000</td>\n",
       "      <td>51.074112</td>\n",
       "      <td>63.102734</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>RMSLE</th>\n",
       "      <td>0.175343</td>\n",
       "      <td>0.170871</td>\n",
       "      <td>0.429966</td>\n",
       "      <td>0.446251</td>\n",
       "      <td>0.175343</td>\n",
       "      <td>0.215432</td>\n",
       "      <td>0.415096</td>\n",
       "      <td>0.437020</td>\n",
       "      <td>0.174533</td>\n",
       "      <td>0.188795</td>\n",
       "      <td>0.374999</td>\n",
       "      <td>0.467985</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "       lr-tradi_train  lr-tradi_val  lr-VC_train    lr-VC_val  \\\n",
       "MSE       2913.873492   2917.112705  2889.202511  3230.881982   \n",
       "MAE         43.792506     43.349235    43.616333    46.157659   \n",
       "RMSE      2913.873492   2917.112705    53.736882    56.577650   \n",
       "RMSLE        0.175343      0.170871     0.429966     0.446251   \n",
       "\n",
       "       poly-tradi_train  poly-tradi_test  poly-VC_train  poly-VC_test  \\\n",
       "MSE         2913.873492      4853.553485    2829.427334   3221.625571   \n",
       "MAE           43.792506        52.430099      43.262779     46.219619   \n",
       "RMSE        2913.873492      4853.553485      53.183959     56.576736   \n",
       "RMSLE          0.175343         0.215432       0.415096      0.437020   \n",
       "\n",
       "       knn-tradi_train  knn-tradi_test  knn-VC_train  knn-VC_test  \n",
       "MSE        2884.757413     3546.840000   2610.137916  3994.920085  \n",
       "MAE          43.934380       46.106306     40.618799    50.240859  \n",
       "RMSE       2884.757413     3546.840000     51.074112    63.102734  \n",
       "RMSLE         0.174533        0.188795      0.374999     0.467985  "
      ]
     },
     "execution_count": 77,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "evaluation = {\n",
    "\"lr-tradi_train\":{\"MSE\":mse_lr_train,\"MAE\":mae_lr_train,\"RMSE\":rmse_lr_train , \"RMSLE\": rmsle_lr_train },\n",
    "\"lr-tradi_val\":{\"MSE\":mse_lr,\"MAE\":mae_lr,\"RMSE\":rmse_lr , \"RMSLE\": rmsle_lr },\n",
    "    \n",
    "\"lr-VC_train\":{\"MSE\":mse_train_scores_lr,\"MAE\":mae_train_score_lr,\"RMSE\":rmse_train_score_lr , \"RMSLE\": rmsle_train_score_lr},\n",
    "\"lr-VC_val\":{\"MSE\":mse_scores_lr,\"MAE\":mae_scores_lr,\"RMSE\":rmse_scores_lr , \"RMSLE\": rmsle_scores_lr},\n",
    "\n",
    "\"poly-tradi_train\":{\"MSE\":mse_poly_train,\"MAE\":mae_poly_train,\"RMSE\":rmse_poly_train  , \"RMSLE\": rmsle_poly_train },\n",
    "\"poly-tradi_test\":{\"MSE\":mse_poly,\"MAE\":mae_poly,\"RMSE\":rmse_poly  , \"RMSLE\": rmsle_poly },\n",
    "\n",
    "\"poly-VC_train\":{\"MSE\":mse_train_scores_poly, \"MAE\":mae_train_score_poly,\"RMSE\":rmse_train_score_poly , \"RMSLE\": rmsle_train_score_poly },\n",
    "\"poly-VC_test\":{\"MSE\":mse_scores_poly, \"MAE\":mae_scores_poly,\"RMSE\":rmse_scores_poly , \"RMSLE\": rmsle_scores_poly },\n",
    "\n",
    "\"knn-tradi_train\":{\"MSE\":mse_knn_train,\"MAE\":mae_knn_train,\"RMSE\":rmse_knn_train  , \"RMSLE\": rmsle_knn_train },\n",
    "\"knn-tradi_test\":{\"MSE\":mse_knn,\"MAE\":mae_knn,\"RMSE\":rmse_knn  , \"RMSLE\": rmsle_knn },\n",
    "\n",
    "\"knn-VC_train\":{\"MSE\":mse_train_scores_knn,\"MAE\":mae_train_score_knn,\"RMSE\":rmse_train_score_knn , \"RMSLE\": rmsle_train_score_knn },\n",
    "\"knn-VC_test\":{\"MSE\":mse_scores_knn,\"MAE\":mae_scores_knn,\"RMSE\":rmse_scores_knn , \"RMSLE\": rmsle_scores_knn }\n",
    "}\n",
    "\n",
    "pd.DataFrame.from_dict(evaluation)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e5d906e8",
   "metadata": {},
   "source": [
    "  D'après les résultats, la régression linéaire est le modèle le plus pertinent, car elle a le MSE le plus faible sur l'ensemble de test et le RMSE moyen le plus faible lors de la validation croisée.\n",
    "\n",
    "Cependant, on peut observer que la régression linéaire a le MSE le plus faible sur\n",
    "l'ensemble de test et un score de validation croisée légèrement meilleur que les autres\n",
    "modèles, ce qui pourrait indiquer qu'elle est moins sujette au sur-apprentissage.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eca3da42",
   "metadata": {},
   "source": [
    "Si l'algorithme a également de mauvaises performances sur l'ensemble de test, cela peut indiquer un sur-apprentissage. \n",
    " \n",
    "Si l'algorithme a de bonnes performances sur l'ensemble d'entraînement, mais de mauvaises performances sur l'ensemble de validation et de test, cela peut indiquer un sur-apprentissage.\n",
    "\n",
    "selon MAE l'algorithme knn sous-apprentissage et  lr sur-apprentissage \n",
    "\n",
    " un RMSE élevé peut indiquer un \"sous-apprentissage\" si le modèle ne parvient pas à capturer les relations complexes dans les données comme l'algo de poly avec l'approch traditionelle \n",
    " \n",
    "Si un modèle a un RMSLE élevé KNN sur les données d'entraînement et de test, cela peut indiquer un sous-apprentissage comme l'algo knn validation croisée test .\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
